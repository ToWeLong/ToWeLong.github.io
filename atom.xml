<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://towelong.github.io/</id>
    <title>WeLong&apos;闲言碎语</title>
    <updated>2019-10-23T06:15:50.873Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://towelong.github.io/"/>
    <link rel="self" href="https://towelong.github.io//atom.xml"/>
    <subtitle>学的不多，用心就好！</subtitle>
    <logo>https://towelong.github.io//images/avatar.png</logo>
    <icon>https://towelong.github.io//favicon.ico</icon>
    <rights>All rights reserved 2019, WeLong&apos;闲言碎语</rights>
    <entry>
        <title type="html"><![CDATA[SpringBoot全局异常处理与自定义异常处理]]></title>
        <id>https://towelong.github.io//post/springboot-exception</id>
        <link href="https://towelong.github.io//post/springboot-exception">
        </link>
        <updated>2019-10-23T05:55:43.000Z</updated>
        <summary type="html"><![CDATA[<blockquote>
<p>下层基础决定上层建筑，所以我今天研究了一波异常处理机制。</p>
</blockquote>
<h2 id="为什么要研究下层基础呢">为什么要研究“下层基础”呢？</h2>
<p>首先，当只有把基础设施给建设完全我们才能快速进行开发，因为<code>SpringBoot</code>相对于<code>Spring</code>而言，已经提高了我们的开发效率，我们只需要在此基础上再完善，最终才能帮助我们快速开发。</p>
]]></summary>
        <content type="html"><![CDATA[<blockquote>
<p>下层基础决定上层建筑，所以我今天研究了一波异常处理机制。</p>
</blockquote>
<h2 id="为什么要研究下层基础呢">为什么要研究“下层基础”呢？</h2>
<p>首先，当只有把基础设施给建设完全我们才能快速进行开发，因为<code>SpringBoot</code>相对于<code>Spring</code>而言，已经提高了我们的开发效率，我们只需要在此基础上再完善，最终才能帮助我们快速开发。</p>
<!-- more -->
<p>话不多说，接下来讲讲我研究的一种思路。</p>
<h3 id="全局异常处理">全局异常处理</h3>
<p>我们首先在<code>SpringBoot</code>工程下创建一个名为<code>exception</code>的包，然后在包下面新建一个类叫<code>GlobalException</code> ,我们利用<code>@ControllerAdvice</code>注解来捕获异常。</p>
<pre><code class="language-java">public class GlobalException {
    @ResponseBody
    @ExceptionHandler(value = Exception.class)
    public Map getSysError(Exception e) {
        Map&lt;String,Object&gt; map = new HashMap&lt;&gt;();
        map.put(&quot;code&quot;, -1);
        map.put(&quot;msg&quot;, e.getMessage());
        map.put(&quot;request&quot;,RequestHelper.getRequestUrl());
        return map;
    }
}    
</code></pre>
<p><code>getSysError</code> 方法就是捕获系统出现的异常的一个方法，然后<code>RequestHelper</code>是我封装的一个获取请求方法和请求<code>URL</code>的类。具体实现如下：</p>
<pre><code class="language-java">public class RequestHelper {

    public static HttpServletRequest getRequest() {
        HttpServletRequest request = ((ServletRequestAttributes) RequestContextHolder.getRequestAttributes()).getRequest();
        return request;
    }
    public static String getRequestUrl() {
        String methods = getRequest().getMethod();
        return methods+&quot; &quot;+getRequest().getServletPath();
    }
}
</code></pre>
<p>然后，根据全局异常处理看看捕获到的异常结果是怎么样的，我们利用 <code>1/0</code>这个大家都很熟悉的一个异常作为例子。</p>
<pre><code class="language-java">@RestController
public class HelloController {
    @GetMapping(&quot;/hello&quot;)
    public int hello() {
        return 1 / 0;
    }
}
</code></pre>
<p>返回结果如下：</p>
<pre><code class="language-json">{
&quot;msg&quot;: &quot;/ by zero&quot;,
&quot;request&quot;: &quot;GET /hello&quot;,
&quot;code&quot;: -1
}
</code></pre>
<p>但是需要注意的一点是，在部署上线项目的时候，我们不能直接去返回具体的系统错误信息，因此，在生产环境中，我们需要修改为<code>“msg”:&quot;服务器开小差了&quot;</code>，类似于这种模糊的错误信息。</p>
<h3 id="自定义异常处理">自定义异常处理</h3>
<p>新建一个<code>HttpException</code>的自定义异常基础类，</p>
<pre><code class="language-java">@Data
public class HttpException extends RuntimeException {
    private String msg;
    private int code;
    private String url = RequestHelper.getRequestUrl();
}
</code></pre>
<p>之后所有的自定义异常类都去继承<code>HttpException</code>，然后还有很重要的一点是为什么<code>HttpException</code>不去继承<code>Exception</code>这个类，而去继承<code>RuntimeException</code>这个类呢？原因请看<br>
[Java自定义异常，应该继承Exception还是Runtime Exception，为什么？][https://www.zhihu.com/question/51970444]</p>
<p>然后在此示例中，我创建了一个<code>NotFound</code>类。</p>
<pre><code class="language-java">@Data
public class NotFound extends HttpException {

    private String msg = &quot;资源不存在&quot;;
    private int code = 999;

    public NotFound(String msg) {
        this.msg = msg;
    }
    public NotFound() {

    }
}
</code></pre>
<p>然后在<code>GlobalExceptin</code> 中添加以下代码：</p>
<pre><code class="language-java">@ControllerAdvice
public class GlobalException {
    // 系统异常捕获
    @ResponseBody
    @ExceptionHandler(value = Exception.class)
    public Map getSysError(Exception e) {
        Map&lt;String,Object&gt; map = new HashMap&lt;&gt;();
        map.put(&quot;code&quot;, -1);
        map.put(&quot;msg&quot;, e.getMessage());
        map.put(&quot;request&quot;,RequestHelper.getRequestUrl());
        return map;
    }
	// 自定义异常捕获
    @ResponseBody
    @ExceptionHandler(value = HttpException.class)
    public Map errorHandler(HttpException ex) {
        Map&lt;String,Object&gt; map = new HashMap&lt;&gt;();
        map.put(&quot;code&quot;, ex.getCode());
        map.put(&quot;msg&quot;, ex.getMsg());
        map.put(&quot;request&quot;,ex.getRequest());
        return map;
    }
}
</code></pre>
<p>我们在<code>@ExceptionHandler(value = HttpException.class)</code>中还是捕获了 <code>HttpException</code>这个类，这就是为什么之前 我们所有的自定义异常类全部继承<code>HttpException</code>这个基类的原因之一了。</p>
<p>然后我们再来测试下<code>NotFound</code>这个异常。</p>
<pre><code class="language-java">@RestController
public class HelloController {
    @GetMapping(&quot;/hello&quot;)
    public int hello() {
        throw new NotFound();
    }
}    
</code></pre>
<p>结果如下：</p>
<pre><code class="language-json">{
&quot;msg&quot;: &quot;资源不存在&quot;,
&quot;request&quot;: &quot;GET /hello&quot;,
&quot;code&quot;: 999
}

</code></pre>
<p>至此，异常处理就已经完成了。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[SpringBoot盐与密码加密]]></title>
        <id>https://towelong.github.io//post/springboot-yan-yu-mi-ma-jia-mi</id>
        <link href="https://towelong.github.io//post/springboot-yan-yu-mi-ma-jia-mi">
        </link>
        <updated>2019-10-22T10:24:01.000Z</updated>
        <summary type="html"><![CDATA[<blockquote>
<p>在学习<code>SpringBoot</code>的过程中，碰到了用户密码加密的问题，因为密码是不能以明文储存的，这是对用户负责</p>
</blockquote>
]]></summary>
        <content type="html"><![CDATA[<blockquote>
<p>在学习<code>SpringBoot</code>的过程中，碰到了用户密码加密的问题，因为密码是不能以明文储存的，这是对用户负责</p>
</blockquote>
<!-- more -->
<h2 id="首先">首先</h2>
<p>​        我在百度和谷歌找了好多种解决方案，但是答案基本上千篇一律，都是一样的，而且只有部分才能解决问题，然后多亏<code>LinCMS</code>开源团队找到了我想要的解决方案，此前在查资料的过程中，找到的一种解决方案中，有一种可以解决，就是<code>Spring security</code>中的<code>BCryptPasswordEncoder</code>方法对密码进行加密，我测试了一下确实可以，而且和我预想中的一模一样，就是同一个密码在加密的时候每次得到的加密字符串都是不一样的，但是唯一一点让我很无奈的是，用<code>Spring security</code>会捆绑一系列的配置，况且我也没用到它，所以这个方案直接被我Pass掉了。</p>
<h2 id="其次">其次</h2>
<p>​      我再说第二种解决方案，使用<code>jhash</code>、<code>jotp</code></p>
<table>
<thead>
<tr>
<th style="text-align:left">依赖</th>
<th style="text-align:left">Github地址</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">jhash</td>
<td style="text-align:left">https://github.com/amdelamar/jhash</td>
</tr>
<tr>
<td style="text-align:left">jotp</td>
<td style="text-align:left">https://github.com/amdelamar/jotp</td>
</tr>
</tbody>
</table>
<pre><code class="language-java">    @Test
    public void test() throws InvalidHashException {
        char[] password = &quot;Hello World!&quot;.toCharArray();
        String hash = Hash.password(password).algorithm(Type.BCRYPT).create();
        System.out.println(hash);
        if(Hash.password(password).verify(&quot;bcrypt:13:60:16:n::$2a$13$aIPs6auOGff6bWWRNmfZleD1rzUQq2Owk8tSKeM9T8t2QqW7yTud.&quot;)) {
            // Passwords match. Login successful!
            System.out.println(&quot;success&quot;);
        }
    }
</code></pre>
<p>这是一小段测试代码，然后加密方式不止<code>BCRYPT</code>这种，也是就盐加密，我选的是这种，其实还有很多具体查看官方文档。<br>
<img src="https://towelong.github.io//post-images/1571739897849.png" alt=""></p>
]]></content>
    </entry>
</feed>